{"version":3,"file":"wait-until.js","sources":["../src/wait-until.ts"],"sourcesContent":["import { futureTick } from './-utils.ts';\n\nconst TIMEOUTS = [0, 1, 2, 5, 7];\nconst MAX_TIMEOUT = 10;\n\ntype Falsy = false | 0 | '' | null | undefined;\n\nexport interface Options {\n  timeout?: number;\n  timeoutMessage?: string;\n}\n\n/**\n  Wait for the provided callback to return a truthy value.\n\n  This does not leverage `settled()`, and as such can be used to manage async\n  while _not_ settled (e.g. \"loading\" or \"pending\" states).\n\n  @public\n  @param {Function} callback the callback to use for testing when waiting should stop\n  @param {Object} [options] options used to override defaults\n  @param {number} [options.timeout=1000] the maximum amount of time to wait\n  @param {string} [options.timeoutMessage='waitUntil timed out'] the message to use in the reject on timeout\n  @returns {Promise} resolves with the callback value when it returns a truthy value\n\n  @example\n  <caption>\n    Waiting until a selected element displays text:\n  </caption>\n  await waitUntil(function() {\n    return find('.my-selector').textContent.includes('something')\n  }, { timeout: 2000 })\n*/\nexport default function waitUntil<T>(\n  callback: () => T | void | Falsy,\n  options: Options = {},\n): Promise<T> {\n  const timeout = 'timeout' in options ? (options.timeout as number) : 1000;\n  const timeoutMessage =\n    'timeoutMessage' in options\n      ? options.timeoutMessage\n      : 'waitUntil timed out';\n\n  // creating this error eagerly so it has the proper invocation stack\n  const waitUntilTimedOut = new Error(timeoutMessage);\n\n  return new Promise(function (resolve, reject) {\n    let time = 0;\n\n    // eslint-disable-next-line require-jsdoc\n    function scheduleCheck(timeoutsIndex: number) {\n      const knownTimeout = TIMEOUTS[timeoutsIndex];\n      const interval = knownTimeout === undefined ? MAX_TIMEOUT : knownTimeout;\n\n      futureTick(function () {\n        time += interval;\n\n        let value: T | void | Falsy;\n        try {\n          value = callback();\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (value) {\n          resolve(value);\n        } else if (time < timeout) {\n          scheduleCheck(timeoutsIndex + 1);\n        } else {\n          reject(waitUntilTimedOut);\n          return;\n        }\n      }, interval);\n    }\n\n    scheduleCheck(0);\n  });\n}\n"],"names":["TIMEOUTS","MAX_TIMEOUT","waitUntil","callback","options","timeout","timeoutMessage","waitUntilTimedOut","Error","Promise","resolve","reject","time","scheduleCheck","timeoutsIndex","knownTimeout","interval","undefined","futureTick","value","error"],"mappings":";;AAEA,MAAMA,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAA;AAChC,MAAMC,WAAW,GAAG,EAAE,CAAA;AAStB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASC,SAASA,CAC/BC,QAAgC,EAChCC,OAAgB,GAAG,EAAE,EACT;EACZ,MAAMC,OAAO,GAAG,SAAS,IAAID,OAAO,GAAIA,OAAO,CAACC,OAAO,GAAc,IAAI,CAAA;EACzE,MAAMC,cAAc,GAClB,gBAAgB,IAAIF,OAAO,GACvBA,OAAO,CAACE,cAAc,GACtB,qBAAqB,CAAA;;AAE3B;AACA,EAAA,MAAMC,iBAAiB,GAAG,IAAIC,KAAK,CAACF,cAAc,CAAC,CAAA;AAEnD,EAAA,OAAO,IAAIG,OAAO,CAAC,UAAUC,OAAO,EAAEC,MAAM,EAAE;IAC5C,IAAIC,IAAI,GAAG,CAAC,CAAA;;AAEZ;IACA,SAASC,aAAaA,CAACC,aAAqB,EAAE;AAC5C,MAAA,MAAMC,YAAY,GAAGf,QAAQ,CAACc,aAAa,CAAC,CAAA;MAC5C,MAAME,QAAQ,GAAGD,YAAY,KAAKE,SAAS,GAAGhB,WAAW,GAAGc,YAAY,CAAA;AAExEG,MAAAA,UAAU,CAAC,YAAY;AACrBN,QAAAA,IAAI,IAAII,QAAQ,CAAA;AAEhB,QAAA,IAAIG,KAAuB,CAAA;QAC3B,IAAI;UACFA,KAAK,GAAGhB,QAAQ,EAAE,CAAA;SACnB,CAAC,OAAOiB,KAAK,EAAE;UACdT,MAAM,CAACS,KAAK,CAAC,CAAA;AACb,UAAA,OAAA;AACF,SAAA;AAEA,QAAA,IAAID,KAAK,EAAE;UACTT,OAAO,CAACS,KAAK,CAAC,CAAA;AAChB,SAAC,MAAM,IAAIP,IAAI,GAAGP,OAAO,EAAE;AACzBQ,UAAAA,aAAa,CAACC,aAAa,GAAG,CAAC,CAAC,CAAA;AAClC,SAAC,MAAM;UACLH,MAAM,CAACJ,iBAAiB,CAAC,CAAA;AACzB,UAAA,OAAA;AACF,SAAA;OACD,EAAES,QAAQ,CAAC,CAAA;AACd,KAAA;IAEAH,aAAa,CAAC,CAAC,CAAC,CAAA;AAClB,GAAC,CAAC,CAAA;AACJ;;;;"}