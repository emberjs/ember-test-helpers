{"version":3,"file":"tab.js","sources":["../../src/dom/tab.ts"],"sourcesContent":["import getRootElement from './get-root-element.ts';\nimport settled from '../settled.ts';\nimport fireEvent, { _buildKeyboardEvent } from './fire-event.ts';\nimport type { Target } from './-target.ts';\nimport { isDocument } from './-target.ts';\nimport { __blur__ } from './blur.ts';\nimport { __focus__ } from './focus.ts';\nimport { isVisible, isDisabled } from '../-utils.ts';\nimport { registerHook, runHooks } from '../helper-hooks.ts';\nimport { log } from './-logging.ts';\n\nconst SUPPORTS_INERT = 'inert' in Element.prototype;\nconst FALLBACK_ELEMENTS = ['CANVAS', 'VIDEO', 'PICTURE'];\n\nregisterHook('tab', 'start', (target: Target) => {\n  log('tab', target);\n});\n\n/**\n  Gets the active element of a document. IE11 may return null instead of the body as\n  other user-agents does when there isn’t an active element.\n  @private\n  @param {Document} ownerDocument the element to check\n  @returns {HTMLElement} the active element of the document\n*/\nfunction getActiveElement(ownerDocument: Document): HTMLElement {\n  return (ownerDocument.activeElement as HTMLElement) || ownerDocument.body;\n}\n\ninterface InertHTMLElement extends HTMLElement {\n  inert: boolean;\n}\n\n/**\n  Compiles a list of nodes that can be focused. Walks the tree, discards hidden elements and a few edge cases. To calculate the right.\n  @private\n  @param {Element} root the root element to start traversing on\n  @returns {Array} list of focusable nodes\n*/\nfunction compileFocusAreas(root: Element = document.body) {\n  const { ownerDocument } = root;\n\n  if (!ownerDocument) {\n    throw new Error('Element must be in the DOM');\n  }\n\n  const activeElement = getActiveElement(ownerDocument);\n  const treeWalker = ownerDocument.createTreeWalker(\n    root,\n    NodeFilter.SHOW_ELEMENT,\n    {\n      acceptNode: (node: HTMLElement) => {\n        // Only visible nodes can be focused, with, at least, one exception; the \"area\" element.\n        // reference: https://html.spec.whatwg.org/multipage/interaction.html#data-model\n        if (node.tagName !== 'AREA' && isVisible(node) === false) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        // Reject any fallback elements. Fallback elements’s children are only rendered if the UA\n        // doesn’t support the element. We make an assumption that they are always supported, we\n        // could consider feature detecting every node type, or making it configurable.\n        const parentNode = node.parentNode as HTMLElement | null;\n        if (\n          parentNode &&\n          FALLBACK_ELEMENTS.indexOf(parentNode.tagName) !== -1\n        ) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        // Rejects inert containers, if the user agent supports the feature (or if a polyfill is installed.)\n        if (SUPPORTS_INERT && (node as InertHTMLElement).inert) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if (isDisabled(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        // Always accept the 'activeElement' of the document, as it might fail the next check, elements with tabindex=\"-1\"\n        // can be focused programmatically, we'll therefor ensure the current active element is in the list.\n        if (node === activeElement) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        // UA parses the tabindex attribute and applies its default values, If the tabIndex is non negative, the UA can\n        // focus it.\n        return node.tabIndex >= 0\n          ? NodeFilter.FILTER_ACCEPT\n          : NodeFilter.FILTER_SKIP;\n      },\n    },\n  );\n\n  let node: Node | null;\n  const elements: HTMLElement[] = [];\n\n  while ((node = treeWalker.nextNode())) {\n    elements.push(node as HTMLElement);\n  }\n\n  return elements;\n}\n\n/**\n  Sort elements by their tab indices.\n  As older browsers doesn't necessarily implement stabile sort, we'll have to\n  manually compare with the index in the original array.\n  @private\n  @param {Array<HTMLElement>} elements to sort\n  @returns {Array<HTMLElement>} list of sorted focusable nodes by their tab index\n*/\nfunction sortElementsByTabIndices(elements: HTMLElement[]): HTMLElement[] {\n  return elements\n    .map((element, index) => {\n      return { index, element };\n    })\n    .sort((a, b) => {\n      if (a.element.tabIndex === b.element.tabIndex) {\n        return a.index - b.index;\n      } else if (a.element.tabIndex === 0 || b.element.tabIndex === 0) {\n        return b.element.tabIndex - a.element.tabIndex;\n      }\n      return a.element.tabIndex - b.element.tabIndex;\n    })\n    .map((entity) => entity.element);\n}\n\n/**\n  @private\n  @param {Element} root The root element or node to start traversing on.\n  @param {HTMLElement} activeElement The element to find the next and previous focus areas of\n  @returns {object} The next and previous focus areas of the active element\n */\nfunction findNextResponders(root: Element, activeElement: HTMLElement) {\n  const focusAreas = compileFocusAreas(root);\n  const sortedFocusAreas = sortElementsByTabIndices(focusAreas);\n  const elements =\n    activeElement.tabIndex === -1 ? focusAreas : sortedFocusAreas;\n\n  const index = elements.indexOf(activeElement);\n  if (index === -1) {\n    return {\n      next: sortedFocusAreas[0],\n      previous: sortedFocusAreas[sortedFocusAreas.length - 1],\n    };\n  }\n\n  return {\n    next: elements[index + 1],\n    previous: elements[index - 1],\n  };\n}\n\n/**\n  Emulates the user pressing the tab button.\n\n  Sends a number of events intending to simulate a \"real\" user pressing tab on their\n  keyboard.\n\n  @public\n  @param {Object} [options] optional tab behaviors\n  @param {boolean} [options.backwards=false] indicates if the the user navigates backwards\n  @param {boolean} [options.unRestrainTabIndex=false] indicates if tabbing should throw an error when tabindex is greater than 0\n  @return {Promise<void>} resolves when settled\n\n  @example\n  <caption>\n    Emulating pressing the `TAB` key\n  </caption>\n  tab();\n\n  @example\n  <caption>\n    Emulating pressing the `SHIFT`+`TAB` key combination\n  </caption>\n  tab({ backwards: true });\n*/\nexport default function triggerTab({\n  backwards = false,\n  unRestrainTabIndex = false,\n} = {}): Promise<void> {\n  return Promise.resolve()\n    .then(() => {\n      return triggerResponderChange(backwards, unRestrainTabIndex);\n    })\n    .then(() => {\n      return settled();\n    });\n}\n\n/**\n  @private\n  @param {boolean} backwards when `true` it selects the previous focus area\n  @param {boolean} unRestrainTabIndex when `true`, will not throw an error if tabindex > 0 is encountered\n  @returns {Promise<void>} resolves when all events are fired\n */\nfunction triggerResponderChange(\n  backwards: boolean,\n  unRestrainTabIndex: boolean,\n): Promise<void> {\n  const root = getRootElement();\n  let ownerDocument: Document;\n  let rootElement: HTMLElement;\n  if (isDocument(root)) {\n    rootElement = root.body;\n    ownerDocument = root;\n  } else {\n    rootElement = root as HTMLElement;\n    ownerDocument = root.ownerDocument as Document;\n  }\n\n  const keyboardEventOptions = {\n    keyCode: 9,\n    which: 9,\n    key: 'Tab',\n    code: 'Tab',\n    shiftKey: backwards,\n  };\n\n  const debugData = {\n    keyboardEventOptions,\n    ownerDocument,\n    rootElement,\n  };\n\n  return Promise.resolve()\n    .then(() => runHooks('tab', 'start', debugData))\n    .then(() => getActiveElement(ownerDocument))\n    .then((activeElement) =>\n      runHooks('tab', 'targetFound', activeElement).then(() => activeElement),\n    )\n    .then((activeElement) => {\n      const event = _buildKeyboardEvent('keydown', keyboardEventOptions);\n      const defaultNotPrevented = activeElement.dispatchEvent(event);\n\n      if (defaultNotPrevented) {\n        // Query the active element again, as it might change during event phase\n        activeElement = getActiveElement(ownerDocument);\n        const target = findNextResponders(rootElement, activeElement);\n        if (target) {\n          if (backwards && target.previous) {\n            return __focus__(target.previous);\n          } else if (!backwards && target.next) {\n            return __focus__(target.next);\n          } else {\n            return __blur__(activeElement);\n          }\n        }\n      }\n\n      return Promise.resolve();\n    })\n    .then(() => {\n      const activeElement = getActiveElement(ownerDocument);\n      return fireEvent(activeElement, 'keyup', keyboardEventOptions).then(\n        () => activeElement,\n      );\n    })\n    .then((activeElement) => {\n      if (!unRestrainTabIndex && activeElement.tabIndex > 0) {\n        throw new Error(\n          `tabindex of greater than 0 is not allowed. Found tabindex=${activeElement.tabIndex}`,\n        );\n      }\n    })\n    .then(() => runHooks('tab', 'end', debugData));\n}\n"],"names":["SUPPORTS_INERT","Element","prototype","FALLBACK_ELEMENTS","registerHook","target","log","getActiveElement","ownerDocument","activeElement","body","compileFocusAreas","root","document","Error","treeWalker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","tagName","isVisible","FILTER_REJECT","parentNode","indexOf","inert","isDisabled","FILTER_ACCEPT","tabIndex","FILTER_SKIP","elements","nextNode","push","sortElementsByTabIndices","map","element","index","sort","a","b","entity","findNextResponders","focusAreas","sortedFocusAreas","next","previous","length","triggerTab","backwards","unRestrainTabIndex","Promise","resolve","then","triggerResponderChange","settled","getRootElement","rootElement","isDocument","keyboardEventOptions","keyCode","which","key","code","shiftKey","debugData","runHooks","event","_buildKeyboardEvent","defaultNotPrevented","dispatchEvent","__focus__","__blur__","fireEvent"],"mappings":"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"}