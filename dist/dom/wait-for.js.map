{"version":3,"file":"wait-for.js","sources":["../../src/dom/wait-for.ts"],"sourcesContent":["import waitUntil from '../wait-until.ts';\nimport getElement from './-get-element.ts';\nimport getElements from './-get-elements.ts';\nimport {\n  type IDOMElementDescriptor,\n  lookupDescriptorData,\n} from 'dom-element-descriptors';\nimport getDescription from './-get-description.ts';\n\nexport interface Options {\n  timeout?: number;\n  count?: number | null;\n  timeoutMessage?: string;\n}\n\n/**\n  Used to wait for a particular selector to appear in the DOM. Due to the fact\n  that it does not wait for general settledness, this is quite useful for testing\n  interim DOM states (e.g. loading states, pending promises, etc).\n\n  @param {string|IDOMElementDescriptor} target the selector or DOM element descriptor to wait for\n  @param {Object} [options] the options to be used\n  @param {number} [options.timeout=1000] the time to wait (in ms) for a match\n  @param {number} [options.count=null] the number of elements that should match the provided selector (null means one or more)\n  @return {Promise<Element|Element[]>} resolves when the element(s) appear on the page\n\n  @example\n  <caption>\n    Waiting until a selector is rendered:\n  </caption>\n  await waitFor('.my-selector', { timeout: 2000 })\n*/\nexport default function waitFor(\n  target: string | IDOMElementDescriptor,\n  options: Options = {},\n): Promise<Element | Element[]> {\n  return Promise.resolve().then(() => {\n    if (typeof target !== 'string' && !lookupDescriptorData(target)) {\n      throw new Error(\n        'Must pass a selector or DOM element descriptor to `waitFor`.',\n      );\n    }\n\n    const { timeout = 1000, count = null } = options;\n    let { timeoutMessage } = options;\n\n    if (!timeoutMessage) {\n      const description = getDescription(target);\n      timeoutMessage = `waitFor timed out waiting for selector \"${description}\"`;\n    }\n\n    let callback: () => Element | Element[] | void | null;\n    if (count !== null) {\n      callback = () => {\n        const elements = Array.from(getElements(target));\n        if (elements.length === count) {\n          return elements;\n        }\n        return;\n      };\n    } else {\n      callback = () => getElement(target);\n    }\n    return waitUntil(callback, { timeout, timeoutMessage });\n  });\n}\n"],"names":["waitFor","target","options","Promise","resolve","then","lookupDescriptorData","Error","timeout","count","timeoutMessage","description","getDescription","callback","elements","Array","from","getElements","length","getElement","waitUntil"],"mappings":";;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,OAAOA,CAC7BC,MAAsC,EACtCC,OAAgB,GAAG,EAAE,EACS;EAC9B,OAAOC,OAAO,CAACC,OAAO,EAAE,CAACC,IAAI,CAAC,MAAM;IAClC,IAAI,OAAOJ,MAAM,KAAK,QAAQ,IAAI,CAACK,oBAAoB,CAACL,MAAM,CAAC,EAAE;AAC/D,MAAA,MAAM,IAAIM,KAAK,CACb,8DACF,CAAC,CAAA;AACH,KAAA;IAEA,MAAM;AAAEC,MAAAA,OAAO,GAAG,IAAI;AAAEC,MAAAA,KAAK,GAAG,IAAA;AAAK,KAAC,GAAGP,OAAO,CAAA;IAChD,IAAI;AAAEQ,MAAAA,cAAAA;AAAe,KAAC,GAAGR,OAAO,CAAA;IAEhC,IAAI,CAACQ,cAAc,EAAE;AACnB,MAAA,MAAMC,WAAW,GAAGC,cAAc,CAACX,MAAM,CAAC,CAAA;MAC1CS,cAAc,GAAG,CAA2CC,wCAAAA,EAAAA,WAAW,CAAG,CAAA,CAAA,CAAA;AAC5E,KAAA;AAEA,IAAA,IAAIE,QAAiD,CAAA;IACrD,IAAIJ,KAAK,KAAK,IAAI,EAAE;MAClBI,QAAQ,GAAGA,MAAM;QACf,MAAMC,QAAQ,GAAGC,KAAK,CAACC,IAAI,CAACC,WAAW,CAAChB,MAAM,CAAC,CAAC,CAAA;AAChD,QAAA,IAAIa,QAAQ,CAACI,MAAM,KAAKT,KAAK,EAAE;AAC7B,UAAA,OAAOK,QAAQ,CAAA;AACjB,SAAA;AACA,QAAA,OAAA;OACD,CAAA;AACH,KAAC,MAAM;AACLD,MAAAA,QAAQ,GAAGA,MAAMM,UAAU,CAAClB,MAAM,CAAC,CAAA;AACrC,KAAA;IACA,OAAOmB,SAAS,CAACP,QAAQ,EAAE;MAAEL,OAAO;AAAEE,MAAAA,cAAAA;AAAe,KAAC,CAAC,CAAA;AACzD,GAAC,CAAC,CAAA;AACJ;;;;"}